# SUDCare Dashboard

Interactive dashboard prototype for the SUDCare chatbot study, built with the Next.js App Router and TypeScript.

## Prerequisites

- Node.js 20.x (matches local tooling and CI)
- npm 10+

## Quick Start

1. Install dependencies:
   ```bash
   npm install
   ```
2. Start the development server:
   ```bash
   npm run dev
   ```
3. Open [`http://localhost:3000`](http://localhost:3000) to explore the dashboard shell and sample widgets.

## Available Scripts

- `npm run dev` — Launch the dev server in turbo mode.
- `npm run build` — Produce an optimized production bundle.
- `npm run start` — Serve the production build locally.
- `npm run lint` — Run ESLint with the Next.js config.
- `npm run format` — Check formatting via Prettier.
- `npm run format:fix` — Apply Prettier fixes.
- `npm run test` — Execute Vitest suites (jsdom environment).
- `npm run ingest-data` — Show CLI usage for the Excel→JSON ingestion script.

## Tech Stack

- Next.js 14 App Router with React 18.
- Tailwind CSS 3 + shadcn/ui primitives (`components.json` manages generated components).
- Recharts and Framer Motion for animated data visualizations.
- TypeScript 5 with shared types in `types/` and linting/formatting via ESLint + Prettier.
- Vitest + Testing Library for unit/component tests.

## Project Layout

```
.
├─ src/
│  ├─ app/            # Route handlers, layouts, API endpoints, and global styles
│  ├─ components/
│  │  ├─ layout/      # Header, footer, and shell chrome
│  │  ├─ dashboard/   # Domain widgets composing the dashboard view
│  │  ├─ charts/      # Chart wrappers and configuration helpers
│  │  └─ ui/          # shadcn/ui building blocks
│  ├─ lib/            # Data loading, transforms, analytics helpers
│  └─ styles/         # Theme documentation and design notes
├─ data/              # JSON fixtures for demo datasets (`all`, `exclude_p266`, etc.)
├─ types/             # Shared TypeScript types and parsing helpers
├─ __tests__/         # Vitest-based unit and component tests
├─ docs/              # Product docs, design references, and screenshots
├─ epics/             # Roadmap and feature planning notes
├─ components.json    # shadcn/ui manifest for generating UI primitives
├─ next.config.mjs    # Next.js configuration
└─ tailwind.config.ts # Tailwind theme tokens and design system glue
```

## Data Flow

- Dashboard data can be supplied as legacy aggregate JSON (current `data/data-*.json`) or via normalized interaction exports generated by the ingestion script.
- `src/lib/data-repository.ts` understands both shapes: it falls back to the normalized payload if provided and recomputes widget metrics on the fly.
- Client-side requests hit `src/app/api/dashboard-data/[dataset]/route.ts`, which validates the dataset key and returns the parsed payload.
- Normalized datasets include participant-level interactions plus a `preaggregated` cache (optional). The ingestion script outputs this structure directly from the Excel workbook.

## Regenerating datasets from the Excel workbook

1. Ensure you have Python 3.9+ available (`python3 --version`). The script uses the built-in ZIP/XML libraries—no additional packages required.
2. Place the latest study export in the repo (default path: `docs/SUDCare Dashboard v0 Dataset.xlsx`). The workbook must expose the normalized `merged_data-all` sheet and follow the schema in `docs/spreadsheet-schema.md`.
3. Run the ingestion script, pointing it at the workbook and an output directory. Example:
   ```bash
   python3 scripts/ingest_dashboard_data.py \
     --source "docs/SUDCare Dashboard v0 Dataset.xlsx" \
     --output data \
     --dataset-prefix sudcare \
     --exclude p266
   ```
   - `--output` controls where JSON files are written. Using `data` overwrites the existing fixtures (`sudcare_all.json` and `sudcare_exclude.json` in this example). Use a staging folder (e.g., `data/normalized`) if you want to inspect diff output first.
   - `--dataset-prefix` is appended to filenames. The example above produces `data/sudcare_all.json` and `data/sudcare_exclude.json`.
   - `--exclude` accepts multiple participant IDs; the trimmed dataset omits any matches.
   - You can invoke the script via npm as well:  
     `npm run ingest-data -- --source "docs/SUDCare Dashboard v0 Dataset.xlsx" --output data --exclude p266 --dataset-prefix sudcare`
4. After generation:
   - Inspect one of the outputs to verify the `meta`, `interactions`, and `participants` blocks look correct.
   - Run `npm test -- __tests__/scripts/ingest-dashboard-data.test.ts` to ensure the ingestion pipeline still succeeds on CI.
   - If replacing the app’s live datasets, copy them into place explicitly:
     ```bash
     cp data/normalized/sudcare_all.json data/data-all.json
     cp data/normalized/sudcare_exclude.json data/data-exclude-p266.json
     ```
     Adjust the paths to match the prefix and output directory you passed to the script.
5. Commit regenerated files along with any code changes. The dashboard will automatically use the normalized payload and recompute aggregates when the app boots.

### Participant filtering

- The header includes a **Participants** control that lets you include or exclude specific participants. The button shows the active filter summary (for example, “2 included”).
- Clicking the control opens a dialog where you can switch between *Include* and *Exclude* modes, search participants, and toggle selections. Charts refresh instantly as you make changes.
- Use the **Clear** action inside the dialog to remove the filter. The control is available whenever the active dataset comes from the ingest script and includes normalized interaction data.
- When a filter is active (or even when using the full dataset), the **Interaction Fulfillment** widget offers a toggle to reveal categories and subcategories for intent-not-met messages.

## Adapting the Dashboard

### Data model overview

- Each dataset JSON must follow the shape below. Validation logic in `types/dashboard.ts` enforces this before the UI renders.

```json
{
  "dataset": "all",
  "last_updated": "2025-09-27",
  "metrics": {
    "weekly_messages": [{ "week": 1, "messages": 111 }],
    "messages_by_user": [{ "participant": "p266", "count": 250 }],
    "categories": [{ "name": "wellness", "count": 55 }],
    "subcategories": [{ "name": "gratitude/acknowledgment", "count": 42 }],
    "suzy_can_respond": [{ "able": "TRUE", "count": 333 }],
    "message_times": [{ "hour": 13, "count": 18 }]
  }
}
```

- `dataset` is a short slug that aligns with the dataset toggle exposed in the UI.
- `last_updated` should be a `YYYY-MM-DD` string so the header displays canonical freshness.
- `metrics` arrays can be renamed to reflect your study terminology, but keep the same structure unless you also update the widget props and the TypeScript types.

### Add or replace datasets

1. Duplicate `data/data-all.json` and tailor the records to your study. Keep numeric fields as numbers so chart scales remain accurate.
2. If you introduce a new dataset key, add it to the `DatasetKey` union in `types/dashboard.ts` and mirror the change in:
   - `DATASET_FILE_MAP` and `BUNDLED_DATASET_PAYLOADS` inside `src/lib/data-repository.ts`.
   - The `DatasetKeys` array and label/description logic in `src/components/dashboard/dashboard-data-provider.tsx`.
3. The provider automatically exposes the dataset through the toggle in `home-dashboard.tsx`. Adjust the quick summary or modal copy there if your new dataset needs different context messaging.
4. Run `npm run dev` and confirm the dataset loads without console validation errors. If you see a `DashboardDataValidationError`, inspect the path noted in the error and ensure the JSON matches the expected schema.

### Customize widgets and layout

- Widget components live under `src/components/dashboard/widgets/`. Each file reads a single slice of `DashboardData` and renders inside a `WidgetCard`, so you can swap the charting logic without affecting the rest of the layout.
- `src/components/dashboard/home-dashboard.tsx` composes the grid. To remove or rename tiles, edit the `summaryMetrics` array and the widget sections in that file. Keep the memoized selectors near the top in sync with any new metric names.
- Cross-widget helpers (e.g., `summarizeAssistantResponses` in `src/lib/dashboard-transforms.ts`) are safe places to add derived metrics before passing them into charts.
- When creating a new widget, export it from `widgets/`, add it to the grid, and provide default fallbacks so the dashboard degrades gracefully if a metric is absent.

### Suggested adaptation workflow

1. Sketch the widgets and metrics you need, mapping each to either an existing metric array or a new addition in the dataset JSON.
2. Update the JSON fixture(s) in `data/` and re-run the app to confirm validation still succeeds.
3. Modify or create widgets to read your metrics, keeping reusable UI primitives in `src/components/ui/` for consistency.
4. Add tests under `__tests__/` to cover critical transforms or formatting if you change data shape or introduce new calculations.

## Testing

Vitest and Testing Library are configured for component-level testing. Run `npm run test` during development, or `npm run test:ci` for a one-off run in CI pipelines.

## Continuous Integration

The GitHub Actions workflow (`.github/workflows/ci.yml`) installs dependencies, runs `npm run lint`, executes `npm run test:ci`, and builds the project on pushes and pull requests targeting `main`.

## Deployment

The app is optimized for Vercel or any platform that supports Next.js 14 serverless output. Use `npm run build` as the build command and ensure the platform’s Node version matches 20.x.

## Tooling Notes

- Tailwind CSS powers utility-first styling with custom tokens defined in `tailwind.config.ts`.
- shadcn/ui primitives live under `src/components/ui`; visit `/sandbox` to browse them.
- Recharts + Framer Motion demos render under `/demo-charts` for animation references.
- Additional product context and decisions are documented in `docs/` and `epics/`.
